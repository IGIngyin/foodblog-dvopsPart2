const chai = require("chai");
const chaiHttp = require("chai-http");
const { app, server } = require("../index");
const { expect } = chai;
const fs = require("fs");
const path = require("path");
 
chai.use(chaiHttp);
 
let baseUrl;
let validPostIds = []; // Store valid post IDs
const invalidPostId = "invalidID"; // A static invalid ID for testing
 
describe("UserComments API", () => {
    before(async () => {
        // Validate server instance
        if (!server || !server.address) {
            throw new Error("Server is not running or improperly initialized.");
        }
        const { address, port } = server.address();
        baseUrl = `http://${address === "::" ? "localhost" : address}:${port}`;
 
        // Load valid post IDs from foodblogs.json
        const filePath = path.join(__dirname, "../utils/foodblogs.json");
        const foodblogs = JSON.parse(fs.readFileSync(filePath, "utf-8"));
        validPostIds = foodblogs.map((post) => post.id);
    });
 
    after(() => {
        // Validate server close
        if (server && typeof server.close === "function") {
            return new Promise((resolve) => {
                server.close(() => resolve());
            });
        } else {
            throw new Error("Server cannot be closed.");
        }
    });
 
    describe("POST /add-comment/:id", () => {
        it("should add a new comment successfully", (done) => {
            chai.request(baseUrl)
                .post(`/add-comment/${validPostIds[0]}`) // Use the first valid ID
                .send({ text: "This is a valid comment." })
                .end((err, res) => {
                    expect(res).to.have.status(201);
                    expect(res.body.message).to.equal("Comment added successfully.");
                    done();
                });
        });
 
        it("should return 400 for inappropriate language", (done) => {
            chai.request(baseUrl)
                .post(`/add-comment/${validPostIds[0]}`) // Use the first valid ID
                .send({ text: "This comment contains asshole." })
                .end((err, res) => {
                    expect(res).to.have.status(400);
                    expect(res.body.message).to.equal("Your comment contains inappropriate language.");
                    done();
                });
        });
 
        it("should return 400 for empty comment", (done) => {
            chai.request(baseUrl)
                .post(`/add-comment/${validPostIds[0]}`) // Use the first valid ID
                .send({ text: "" })
                .end((err, res) => {
                    expect(res).to.have.status(400);
                    expect(res.body.message).to.equal("Comment cannot be empty.");
                    done();
                });
        });
 
        it("should return 404 for a non-existent post ID", (done) => {
            chai.request(baseUrl)
                .post(`/add-comment/${invalidPostId}`)
                .send({ text: "Valid comment text" })
                .end((err, res) => {
                    expect(res).to.have.status(404);
                    expect(res.body.message).to.equal("Post ID does not exist.");
                    done();
                });
        });
 
        it("should return 400 for a comment exceeding max length", (done) => {
            const longComment = "a".repeat(201); // 201 characters
            chai.request(baseUrl)
                .post(`/add-comment/${validPostIds[0]}`) // Use the first valid ID
                .send({ text: longComment })
                .end((err, res) => {
                    expect(res).to.have.status(400);
                    expect(res.body.message).to.include("exceeds maximum allowed length");
                    done();
                });
        });
    });
 
    describe("GET /get-comments/:id", () => {
        it("should retrieve comments for a valid post ID", (done) => {
            chai.request(baseUrl)
                .get(`/get-comments/${validPostIds[0]}`) // Use the first valid ID
                .end((err, res) => {
                    expect(res).to.have.status(200);
                    expect(res.body).to.be.an("array");
                    done();
                });
        });
 
        it("should return 404 for a post with no comments", (done) => {
            chai.request(baseUrl)
                .get(`/get-comments/${validPostIds[1]}`) // Use another valid ID
                .end((err, res) => {
                    expect(res).to.have.status(404);
                    expect(res.body.message).to.equal("No comments found for this post.");
                    done();
                });
        });
    });
 
    describe("GET /get-post/:id", () => {
        it("should return the post for a valid ID", (done) => {
            chai.request(baseUrl)
                .get(`/get-post/${validPostIds[0]}`) // Use the first valid ID
                .end((err, res) => {
                    expect(res).to.have.status(200);
                    expect(res.body).to.be.an("object");
                    done();
                });
        });
 
        it("should return 404 for a non-existing post ID", (done) => {
            chai.request(baseUrl)
                .get(`/get-post/${invalidPostId}`)
                .end((err, res) => {
                    expect(res).to.have.status(404);
                    expect(res.body.message).to.equal("Post not found.");
                    done();
                });
        });
    });
});
 
 
const fs = require("fs").promises;
const path = require("path");
const { v4: uuidv4 } = require("uuid");
 
const commentsFilePath = path.join(__dirname, "comments.json");
const foodblogsFilePath = path.join(__dirname, "foodblogs.json");
const bannedWordsFilePath = path.join(__dirname, "bannedWords.json");
async function getPostById(req, res) {
    const { id } = req.params;
    try {
        const posts = await readJSON(foodblogsFilePath);
        const post = posts.find((p) => p.id === id);
 
        if (post) {
            res.status(200).json(post);
        } else {
            res.status(404).json({ message: "Post not found." });
        }
    } catch (error) {
        console.error("Error retrieving post by ID:", error);
        res.status(500).json({ message: "Internal server error." });
    }
}
 
// Load banned words dynamically from JSON
async function loadBannedWords() {
    try {
        const data = await fs.readFile(bannedWordsFilePath, "utf8");
        return JSON.parse(data);
    } catch (error) {
        console.error("Error loading banned words:", error);
        return []; // Return an empty list if the file cannot be read
    }
}
 
// Utility to read JSON files
async function readJSON(filePath) {
    try {
        const data = await fs.readFile(filePath, "utf8");
        return JSON.parse(data);
    } catch (error) {
        if (error.code === "ENOENT") {
            console.warn(`File ${filePath} not found. Initializing.`);
            await fs.writeFile(filePath, JSON.stringify({}, null, 2), "utf8");
            return {}; // Return an empty object
        }
        throw error;
    }
}
 
// Utility to write JSON files
async function writeJSON(filePath, data) {
    try {
        await fs.writeFile(filePath, JSON.stringify(data, null, 2), "utf8");
    } catch (error) {
        console.error(`Error writing to file ${filePath}:`, error);
        throw error;
    }
}
 
async function containsBannedWords(text) {
    const bannedWords = await loadBannedWords();
    const regex = new RegExp(`\\b(${bannedWords.join("|")})\\b|\\W(${bannedWords.join("|")})`, "i");
    return regex.test(text);
}
 
 
async function addComment(req, res) {
    const { id } = req.params;
    const { text } = req.body;
 
    const MAX_COMMENT_LENGTH = 200;
 
    try {
        // Validate post ID
        const posts = await readJSON(foodblogsFilePath);
        const postExists = posts.some((post) => post.id === id);
        if (!postExists) {
            return res.status(404).json({ message: "Post ID does not exist." });
        }
 
        // Validate empty or missing comment
        if (!text || text.trim() === "") {
            return res.status(400).json({ message: "Comment cannot be empty." });
        }
 
        // Validate inappropriate language
        if (await containsBannedWords(text)) {
            console.log("Banned word detected in comment:", text);
            return res.status(400).json({
                message: "Your comment contains inappropriate language.",
            });
        }
 
        // Validate comment length
        if (text.length > MAX_COMMENT_LENGTH) {
            return res.status(400).json({
                message: `Comment exceeds maximum allowed length of ${MAX_COMMENT_LENGTH} characters.`,
            });
        }
 
        // Add comment to JSON
        const comments = await readJSON(commentsFilePath);
        if (!comments[id]) comments[id] = [];
        const newComment = {
            id: uuidv4(),
            text,
            timestamp: new Date().toISOString(),
        };
        comments[id].push(newComment);
        await writeJSON(commentsFilePath, comments);
 
        return res.status(201).json({
            message: "Comment added successfully.",
            comment: newComment,
        });
    } catch (error) {
        console.error("Error adding comment:", error);
        return res.status(500).json({ message: "Internal server error." });
    }
}
 
// Get comments for a post
async function getComments(req, res) {
    const { id } = req.params;
 
    try {
        const comments = await readJSON(commentsFilePath);
        if (!comments[id] || comments[id].length === 0) {
            return res.status(404).json({ message: "No comments found for this post." });
        }
        return res.status(200).json(comments[id]);
    } catch (error) {
        console.error("Error fetching comments:", error);
        return res.status(500).json({ message: "Internal server error." });
    }
}
 
module.exports = {
    getPostById,
    getComments,
    addComment,
};
 
 